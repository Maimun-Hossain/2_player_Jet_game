
  1. Database Implementation (Leaderboard)

  Concept: Why do we need a database for a game?
   * In any game, if you want to remember things between playing sessions – like high scores, player progress, or user accounts – you need a way to store that information
     permanently. This is where a database comes in.
   * For our game, we only need to store the leaderboard entries (player name, score, and when the match happened).

  Technologies Used (A-Z):

   * MySQL: This is the actual database software where our data is physically stored. Think of it as a smart filing cabinet.
   * JPA (Java Persistence API) / Hibernate: These are Java technologies that make it super easy for our Java code to talk to the MySQL database. Instead of writing complex
     database commands directly, we can work with regular Java objects, and JPA/Hibernate automatically translate those objects into database records and vice-versa. This is
     called an ORM (Object-Relational Mapping).
   * Spring Data JPA: This is a part of Spring Boot that simplifies using JPA even further. It allows us to create powerful "repositories" (think of them as specialized data
     access objects) just by defining simple interfaces, without writing much code at all.

  Files/Classes Involved:

   1. `Leaderboard.java` (The Data Model)
       * Purpose: This Java class defines what a single entry on our leaderboard looks like. It's our "score record" blueprint.
       * Key Code & Why:

    1         package com.example.jetgame.model;
    2
    3         import jakarta.persistence.*; // Important JPA annotations
    4         import java.sql.Timestamp;    // To store the date and time
    5
    6         @Entity // This tells JPA that this class represents a table in the database
    7         @Table(name = "leaderboard") // Specifically, this Java object maps to a table named "leaderboard"
    8         public class Leaderboard {
    9
   10             @Id // Marks 'id' as the unique identifier (primary key) for each record
   11             @GeneratedValue(strategy = GenerationType.IDENTITY) // Tells the database to automatically generate this ID for new records
   12             private Long id; // Unique ID for each score entry
   13
   14             @Column(name = "player_name") // Maps this Java field to a database column named "player_name"
   15             private String playerName; // The name of the player who achieved the score
   16
   17             @Column(name = "score") // Maps to a database column named "score"
   18             private int score; // The score achieved in that match
   19
   20             @Column(name = "match_date") // Maps to a database column named "match_date"
   21             private Timestamp matchDate; // The exact date and time the score was recorded
   22
   23             // ... (constructors, getters, and setters follow) ...
   24         }
       * Your explanation point: "I defined the Leaderboard class, which acts as the blueprint for storing each score in our database. I used annotations like @Entity and
         @Table to tell Java how this class connects to our leaderboard table in MySQL."

   2. `LeaderboardRepository.java` (The Data Access Layer)
       * Purpose: This is an interface that Spring Data JPA automatically turns into code that can perform operations (like saving, finding, deleting) on our Leaderboard data
         in the database.
       * Key Code & Why:

    1         package com.example.jetgame.repository;
    2
    3         import com.example.jetgame.model.Leaderboard;
    4         import org.springframework.data.jpa.repository.JpaRepository;
    5         import java.util.List;
    6
    7         public interface LeaderboardRepository extends JpaRepository<Leaderboard, Long> {
    8             // Spring Data JPA automatically understands this method name!
    9             // It will generate SQL to find the top 10 scores, ordered by score descending.
   10             List<Leaderboard> findTop10ByOrderByScoreDesc();
   11         }
       * Your explanation point: "I created the LeaderboardRepository interface. By extending JpaRepository, I instantly got methods to save and retrieve leaderboard data. I
         also added a special method findTop10ByOrderByScoreDesc() which Spring automatically turns into a query to get the top 10 scores for our scoreboard."

   3. `GameService.java` (Saving Scores)
       * Purpose: This is where the game logic decides when to save scores. After a game ends, GameService will use the LeaderboardRepository to save the results.
       * Key Code & Why:

    1         // ... (inside GameService class) ...
    2         @Autowired // Tells Spring to automatically provide an instance of LeaderboardRepository
    3         private final LeaderboardRepository leaderboardRepository; // Our tool to talk to the database
    4
    5         // ... (inside update() method, when game timer runs out) ...
    6         public void update() {
    7             if (System.currentTimeMillis() - gameStartTime > 30000) { // If 30 seconds are up
    8                 gameOver = true;
    9                 stopPowerUpSpawner();
   10                 saveGameResults(); // <--- This calls the score-saving method
   11                 return;
   12             }
   13             // ...
   14         }
   15
   16         public void saveGameResults() {
   17             if (gameState.getPlayers().size() == 2) { // Only save if there were two players
   18                 Player player1 = gameState.getPlayers().get(0);
   19                 Player player2 = gameState.getPlayers().get(1);
   20
   21                 Timestamp matchDate = new Timestamp(System.currentTimeMillis()); // Get current time
   22
   23                 // Use the repository to save each player's score to the database
   24                 leaderboardRepository.save(new Leaderboard(player1.getName(), player1.getScore(), matchDate));
   25                 leaderboardRepository.save(new Leaderboard(player2.getName(), player2.getScore(), matchDate));
   26             }
   27         }
       * Your explanation point: "In the GameService, I ensured that when a game ends, the saveGameResults() method is called. This method then uses the leaderboardRepository
         (which I got automatically from Spring using @Autowired) to save the final score of both players to the database, along with the timestamp of the match."

   4. `LeaderboardController.java` (Fetching Scores for Frontend)
       * Purpose: This class provides a simple web address (an "API endpoint") that the frontend can ask for the latest leaderboard data.
       * Key Code & Why:

   1         // ... (inside LeaderboardController class) ...
   2         @Autowired
   3         private final LeaderboardRepository leaderboardRepository; // Our tool to talk to the database
   4
   5         @GetMapping // This means if someone visits "/api/leaderboard" with a GET request, this method runs
   6         public List<Leaderboard> getLeaderboard() {
   7             // Uses the repository to get the top 10 scores sorted by score
   8             return leaderboardRepository.findTop10ByOrderByScoreDesc();
   9         }
       * Your explanation point: "I set up a REST API endpoint in LeaderboardController.java so the frontend could easily ask for the latest high scores. When the frontend
         requests /api/leaderboard, my code here uses the leaderboardRepository to fetch the top 10 scores and sends them back."

   5. `application.properties` (Database Connection Settings)
       * Purpose: This file tells Spring Boot how to connect to our MySQL database.
       * Key Code & Why:

   1         spring.datasource.url=jdbc:mysql://localhost:3306/jetgame
   2         spring.datasource.username=root
   3         spring.datasource.password=
   4         spring.jpa.hibernate.ddl-auto=update
       * Your explanation point: "I configured the application.properties file to tell our Spring Boot application how to connect to our MySQL database. This includes the
         database address, username, and password. The ddl-auto=update setting was used during development to automatically create or update the leaderboard table structure
         based on our Leaderboard.java model."

  ---

  This breakdown covers the full cycle of database interaction. I will provide the next section when you are ready.Okay, for your presentation, I'll detail the Database
  Implementation. It covers why databases store game info, uses MySQL, JPA/Hibernate for ORM, and Spring Data JPA for simplification. I'll explain Leaderboard.java as the
  data model, LeaderboardRepository.java for data access, GameService.java for score-saving logic, and LeaderboardController.java for frontend access. I'll also clarify
  application.properties for database connection, ensuring you understand "why I code this line" for each component, making sure to highlight how it directly contributed to
  the project. I'll give you the next section shortly.
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ ✓  WriteTodos Set 4 todo(s)                                                                                                                                                │
│                                                                                                                                                                            │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

> what about threading

✦ The user's threading question, accompanied by irrelevant Python/C++ snippets, shows a misunderstanding of the current Java project's implementation. I need to clarify that
  these snippets are external, then deliver a detailed, A-Z explanation of threading within our Java game, covering concepts, relevant Java technologies
  (ScheduledExecutorService, Executors, Runnable, TimeUnit), and key code snippets in GameService.java and GameController.java, linking it all back to their contribution.
  I'll begin by addressing the snippet context.
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ ✓  WriteTodos Set 4 todo(s)                                                                                                                                                │
│                                                                                                                                                                            │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
✦ You're asking about threading, which is a fantastic topic for a game! However, the code snippets you provided seem to be from a Python project (mentioning _thread,
  threading.Thread, _asyncio_thread_main) and a C++ project (mentioning std::thread, Thread class).

  Our "JET FIGHTER - 2 PLAYER" game is implemented in Java using Spring Boot. So, while the concept of threading is the same, the specific code and how it's used will look
  different in our Java application.

  Let's discuss threading specifically as it applies to our Java game:

  ---

  2. Threading (Smooth Gameplay & Dynamic Power-Up Spawning)

  Concept: What is Threading and why is it vital for a game?
   * Imagine your computer program is doing a job. Normally, it does one step after another, in a single line. This is like a single person doing all the tasks.
   * Threading allows a program to do multiple tasks at the same time or in parallel. This is like having multiple people working on different tasks simultaneously.
   * Why is this important for a game?
       * Responsiveness: If the game only did one thing at a time, it would freeze while calculating complex physics or waiting for network data. With threading, the game can
         keep responding to player input while other calculations happen in the background.
       * Background Tasks: We can have separate "workers" for things like updating game physics, spawning power-ups, or sending network messages without interrupting the main
         flow.

  Technologies Used (A-Z in Java):

   * `java.util.concurrent` package: This is Java's built-in set of tools for managing threads and concurrent tasks.
   * `ScheduledExecutorService`: This is a powerful tool from Java's concurrency utilities. It acts like a "task scheduler" that can run tasks repeatedly at fixed intervals,
     or after a delay. We use it for both updating the game state (the "game loop") and for spawning power-ups.
   * `Executors`: A utility class that helps create different types of ExecutorService instances, including ScheduledExecutorService.
   * `Runnable`: This is a Java interface that represents a task that can be executed by a thread. The code we want to run in a separate thread is put inside a Runnable.
   * `TimeUnit`: An enum used with ScheduledExecutorService to specify time units (e.g., seconds, milliseconds).

  Files/Classes Involved & How Threading is Used:

   1. `GameService.java` (Power-Up Spawning Thread)
       * Purpose: GameService needs to randomly spawn power-ups throughout the game. We don't want this spawning to happen instantly or be tied directly to a player action.
         It needs to be a background task that occurs independently.
       * Key Code & Why:

    1         // ... (inside GameService class) ...
    2
    3         // This is our "task scheduler" for spawning power-ups.
    4         // It's created to run tasks on a single separate thread.
    5         private ScheduledExecutorService powerUpSpawner = Executors.newSingleThreadScheduledExecutor();
    6         private final Random random = new Random(); // Used to make spawning random
    7
    8         // ... (constructor and other methods) ...
    9
   10         /**
   11          * Starts the power-up spawning mechanism.
   12          * Ensures any previous spawner is shut down before starting a new one.
   13          * Power-ups spawn between 5 and 10 seconds.
   14          */
   15         public void startPowerUpSpawner() {
   16             // Before starting, ensure any old spawner is completely stopped
   17             if (powerUpSpawner != null && !powerUpSpawner.isShutdown()) {
   18                 powerUpSpawner.shutdownNow();
   19             }
   20             // Create a brand new single-threaded scheduler
   21             powerUpSpawner = Executors.newSingleThreadScheduledExecutor();
   22             // Schedule the 'spawnPowerUp' method to run repeatedly:
   23             // - Start immediately (0 initial delay)
   24             // - Run every 10 seconds
   25             // - With a fixed rate (meaning 10 seconds between the start of each task)
   26             powerUpSpawner.scheduleAtFixedRate(this::spawnPowerUp, 5, 10, TimeUnit.SECONDS);
   27         }
   28
   29         /**
   30          * Stops the power-up spawning mechanism.
   31          * Called when the game ends or is reset to clean up resources.
   32          */
   33         public void stopPowerUpSpawner() {
   34             if (powerUpSpawner != null && !powerUpSpawner.isShutdown()) {
   35                 powerUpSpawner.shutdownNow(); // Forcefully stop all tasks and the thread
   36             }
   37         }
   38
   39         /**
   40          * The actual task that gets run by the 'powerUpSpawner' thread.
   41          * This method randomly selects a power-up type and position, then adds it to the game state.
   42          */
   43         private void spawnPowerUp() {
   44             if (gameState.getPlayers().size() < 2 || gameOver) return; // Only spawn if game is active
   45             // ... (logic to create and add a PowerUp to gameState.getPowerUps()) ...
   46         }
       * Your explanation point: "I helped implement the power-up spawning using Java's `ScheduledExecutorService`. This ensures that power-ups appear randomly on their own
         schedule (every 5-10 seconds) in the game without interrupting player actions or the main game logic. It runs on its own separate 'thread' (like a background worker)
         so it doesn't slow anything down."

   2. `GameController.java` (Game Loop Thread)
       * Purpose: The GameService has an update() method that advances the game state (moves bullets, checks collisions, etc.). This update() method needs to be called very
         frequently and consistently to make the game fluid. A dedicated thread (the "game loop") handles this.
       * Key Code & Why:

    1         // ... (inside GameController class) ...
    2
    3         private ScheduledExecutorService executorService; // Our "task scheduler" for the main game loop
    4
    5         // ... (other methods) ...
    6
    7         /**
    8          * Initializes and starts the main game update loop.
    9          * This scheduled task periodically calls GameService.update()
   10          * and then broadcasts the updated game state to all connected clients.
   11          */
   12         private void startGameLoop() {
   13             // Ensure any previous game loop is completely shut down before starting a new one.
   14             // This prevents old game loops from running alongside new ones, especially during game resets.
   15             if (executorService != null && !executorService.isShutdown()) {
   16                 executorService.shutdownNow();
   17             }
   18             // Create a new single-threaded scheduler for our game loop
   19             executorService = Executors.newSingleThreadScheduledExecutor();
   20             // Schedule a task (a Java Lambda function here) to run repeatedly:
   21             // - Start immediately (0 initial delay)
   22             // - Run every 16 milliseconds (approximately 60 times per second)
   23             executorService.scheduleAtFixedRate(() -> {
   24                 if (gameService.isGameOver()) { // Check if the game has ended
   25                     // Send final game state to clients and stop this game loop thread
   26                     messagingTemplate.convertAndSend("/topic/game", new GameMessage(MessageType.GAME_OVER, gameService.getGameState()));
   27                     executorService.shutdown(); // Stop the game loop
   28                 } else {
   29                     // Otherwise, tell GameService to update the game world
   30                     gameService.update();
   31                     // Send the new, updated game state to all clients
   32                     messagingTemplate.convertAndSend("/topic/game", new GameMessage(MessageType.SCORE_UPDATE, gameService.getGameState()));
   33                 }
   34             }, 0, 16, TimeUnit.MILLISECONDS); // 16ms delay = ~60 frames per second
   35         }
       * Your explanation point: "I was responsible for setting up the main game loop using a ScheduledExecutorService in the GameController. This creates a separate 'thread'
         that constantly calls the GameService.update() method (about 60 times per second) to process all game physics, movements, and collisions. This dedicated loop ensures
         that the game runs smoothly and consistently, and that all players see the most up-to-date game state in real-time."

  ---

  Summary for your explanation:
   * You'll be describing how threading makes the game responsive and allows background tasks.
   * Mention the `ScheduledExecutorService` as the main tool for scheduling tasks on separate threads.
   * Give specific examples:
       * Power-up spawning as an independent, timed background task.
       * The game loop as a constant, rapid update of game physics and state.
   * Point to GameService.java for power-up spawning and GameController.java for the main game loop.

  This should give you a solid foundation to explain the threading aspect thoroughly! Let me know when you're ready for the next section.Okay, I need to clarify threading for
  you in the context of our Java game, as the snippets you provided are from Python/C++.

  Threading in Our Java Game:

  Threading allows our game to perform multiple tasks concurrently, improving responsiveness and enabling background operations. We achieve this using Java's
  java.util.concurrent package, specifically ScheduledExecutorService, Executors, Runnable, and TimeUnit.

  1. Power-Up Spawning (`GameService.java`):
  In GameService.java, the powerUpSpawner (a ScheduledExecutorService) manages power-up generation. The startPowerUpSpawner() method creates a single-threaded scheduler and
  calls spawnPowerUp() every 10 seconds. stopPowerUpSpawner() cleanly shuts it down. This background thread ensures power-ups appear without disrupting gameplay.

  Your explanation: "I helped implement the power-up spawning using Java's ScheduledExecutorService. This ensures that power-ups appear randomly on their own schedule (every
  5-10 seconds) in the game without interrupting player actions or the main game logic. It runs on its own separate 'thread' (like a background worker) so it doesn't slow
  anything down."

  2. Game Loop (`GameController.java`):
  GameController.java contains the main game loop, also managed by a ScheduledExecutorService called executorService. The startGameLoop() method, called when the game starts,
  schedules a task to run every 16 milliseconds (roughly 60 FPS). This task calls GameService.update() to advance the game state and then broadcasts it to clients. This
  dedicated thread guarantees consistent game updates and a fluid experience.

  Your explanation: "I was responsible for setting up the main game loop using a ScheduledExecutorService in the GameController. This creates a separate 'thread' that
  constantly calls the GameService.update() method (about 60 times per second) to process all game physics, movements, and collisions. This dedicated loop ensures that the
  game runs smoothly and consistently, and that all players see the most up-to-date game state in real-time."

  Summary: You'll explain how threading provides responsiveness and enables background tasks like power-up spawning and constant game state updates, pointing to
  GameService.java for power-up spawning and GameController.java for the main game loop.

  Let me know when you're ready for the next section!
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ ✓  WriteTodos Set 4 todo(s)                                                                                                                                                │
│                                                                                                                                                                            │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
✦ Okay, user wants more. I'll explain Networking (WebSockets & REST) for our Java game, A-Z.
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ ✓  WriteTodos Set 4 todo(s)                                                                                                                                                │
│                                                                                                                                                                            │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
✦ 3. Networking (WebSockets & REST APIs)

  Concept: How does a web game communicate with its server?
   * For any online game, the client (your web browser running the game) needs to talk to the server (our Spring Boot application) to send actions, receive updates, and keep
     everything synchronized.
   * We use two main types of communication for different purposes: WebSockets for real-time, constant updates, and REST APIs for simpler, request-response tasks.

  Why is it important for our game?
   * Real-time Interaction: When you move your jet or shoot a bullet, the server needs to know immediately, and all players need to see the updated game state in real-time.
     WebSockets are perfect for this.
   * Game State Synchronization: Keeps all players and the server on the same page about what's happening in the game.
   * Data Management: Allows the frontend to ask for information (like the leaderboard) or trigger server actions (like saving scores).

  Technologies Used (A-Z):

   * WebSockets: A communication protocol that provides a full-duplex (two-way) communication channel over a single TCP connection. Once established, the connection stays
     open, allowing the server and client to send messages back and forth very quickly without needing to constantly re-establish a connection. Ideal for real-time
     applications like games.
   * STOMP (Simple Text Oriented Messaging Protocol): WebSockets are low-level. STOMP is a higher-level messaging protocol that sits on top of WebSockets. It makes sending
     and receiving structured messages (like our GameMessage objects) much easier, especially with a message broker.
   * Spring Boot WebSocket (STOMP messaging): Spring Boot has excellent support for building WebSocket servers that use STOMP. It handles all the complexities of the
     protocol.
   * REST APIs (Representational State Transfer Application Programming Interfaces): A standard way to build web services. It's typically request-response based (client asks,
     server replies, connection closes). Good for data that doesn't need constant updates.
   * `SockJS`: A JavaScript library that provides a WebSocket-like object that tries to use native WebSockets first, but falls back to other browser-compatible communication
     techniques if WebSockets aren't available (e.g., polling, streaming). This ensures our game works in older browsers.
   * `Stomp.js`: A JavaScript library that provides a STOMP client. It allows our frontend game.js to easily send and receive STOMP messages over the WebSocket connection.

  Files/Classes Involved & How Networking is Used:

   1. `WebSocketConfig.java` (Server-Side WebSocket Setup)
       * Purpose: This configuration class tells Spring Boot how to set up the WebSocket server and the STOMP message broker.
       * Key Code & Why:

    1         // ... (inside WebSocketConfig class) ...
    2
    3         @EnableWebSocketMessageBroker // Activates WebSocket message handling, backed by a message broker
    4         public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    5
    6             @Override
    7             public void configureMessageBroker(MessageBrokerRegistry config) {
    8                 // Defines a simple in-memory message broker.
    9                 // Messages sent to destinations prefixed with "/topic" are broadcast to all subscribed clients.
   10                 config.enableSimpleBroker("/topic");
   11                 // Messages sent from clients to the server (for methods annotated with @MessageMapping)
   12                 // must be prefixed with "/app".
   13                 config.setApplicationDestinationPrefixes("/app");
   14             }
   15
   16             @Override
   17             public void registerStompEndpoints(StompEndpointRegistry registry) {
   18                 // Registers the "/jet-game" endpoint. Clients connect to this URL.
   19                 // .withSockJS() enables SockJS fallback for broader browser compatibility.
   20                 registry.addEndpoint("/jet-game").withSockJS();
   21             }
   22         }
       * Your explanation point: "I configured the server-side WebSocket communication using WebSocketConfig.java. This sets up a message broker, which is like a central hub
         for messages. Clients send game actions to /app destinations, and the server broadcasts game state updates to all connected clients via /topic destinations. I also
         enabled SockJS for broader browser compatibility."

   2. `GameController.java` (Handling Client Game Actions)
       * Purpose: This class receives specific game actions from clients via WebSockets and delegates them to the GameService for processing. It also manages sending game
         state updates.
       * Key Code & Why:

    1         // ... (inside GameController class) ...
    2
    3         // @MessageMapping("/join") means this method runs when client sends to "/app/join"
    4         @MessageMapping("/join")
    5         public void join(String playerName) {
    6             gameService.addPlayer(playerName); // Tell GameService a player joined
    7             if (gameService.getGameState().getPlayers().size() == 1) {
    8                 // If 1 player, tell client to wait (sends to "/topic/game")
    9                 messagingTemplate.convertAndSend("/topic/game", new GameMessage(MessageType.WAITING_FOR_PLAYER, playerName));
   10             } else if (gameService.getGameState().getPlayers().size() == 2) {
   11                 startGameLoop(); // If 2 players, start the game loop
   12                 // Tell all clients game is starting with initial state (sends to "/topic/game")
   13                 messagingTemplate.convertAndSend("/topic/game", new GameMessage(MessageType.GAME_START, gameService.getGameState()));
   14             }
   15         }
   16
   17         // @MessageMapping("/action") runs when client sends to "/app/action"
   18         @MessageMapping("/action")
   19         public void handleAction(PlayerAction action) {
   20             if (gameService.isGameOver()) return; // Don't process actions if game is over
   21             if (action.getAction().equals("UP") || action.getAction().equals("DOWN")) {
   22                 gameService.movePlayer(action.getPlayer(), action.getAction()); // Delegate to GameService for movement
   23             } else if ("SHOOT".equals(action.getAction())) {
   24                 gameService.shoot(action.getPlayer()); // Delegate to GameService for shooting
   25             }
   26         }
       * Your explanation point: "In GameController.java, I set up the endpoints that listen for player actions over WebSockets. For instance, when a player clicks 'PLAY' and
         enters their name, a /app/join message is sent. When they move or shoot, an /app/action message is sent. The @MessageMapping annotation tells Spring which method
         should handle which incoming message. This is how the server knows what players are doing in real-time."

   3. `LeaderboardController.java` (REST API for Scoreboard)
       * Purpose: Provides a standard HTTP endpoint for the frontend to retrieve the leaderboard data.
       * Key Code & Why:

   1         // ... (inside LeaderboardController class) ...
   2         @RestController // Marks this as a REST controller
   3         @RequestMapping("/api/leaderboard") // Base URL: "/api/leaderboard"
   4
   5         @GetMapping // This method handles HTTP GET requests to "/api/leaderboard"
   6         public List<Leaderboard> getLeaderboard() {
   7             // Uses the repository to fetch the top 10 scores
   8             return leaderboardRepository.findTop10ByOrderByScoreDesc();
   9         }
       * Your explanation point: "I implemented the REST API for the scoreboard. This means I created a standard web address (/api/leaderboard) that the frontend can visit to
         ask for the latest high scores. The @GetMapping annotation ensures this method runs for standard web requests, fetching the data from the database and sending it
         back to the browser to display."

   4. `game.js` (Client-Side WebSocket & REST Interaction)
       * Purpose: The JavaScript in the browser needs to establish the WebSocket connection, send player actions, and receive/process game state updates. It also calls the
         REST API for the leaderboard.
       * Key Code & Why:

    1         // ... (global variables) ...
    2         let stompClient = null; // Our STOMP client in the browser
    3
    4         function connect() {
    5             const socket = new SockJS('/jet-game'); // Connect to the SockJS endpoint on the server
    6             stompClient = Stomp.over(socket); // Create STOMP client over SockJS
    7             stompClient.connect({}, (frame) => { // Establish STOMP connection
    8                 // Subscribe to the public game topic for all game updates
    9                 stompClient.subscribe('/topic/game', (message) => {
   10                     handleGameMessage(JSON.parse(message.body)); // Process server messages
   11                 });
   12                 stompClient.send("/app/join", {}, playerName); // Send join message to server
   13             });
   14             // ... (error handling) ...
   15         }
   16
   17         function sendAction(actionType) {
   18             // Send player action to the server (e.g., UP, DOWN, SHOOT)
   19             stompClient.send("/app/action", {}, JSON.stringify({ player: playerName, action: actionType }));
   20         }
   21
   22         function handleGameMessage(message) {
   23             // Processes different types of messages from the server
   24             switch (message.type) {
   25                 case 'GAME_START': startGame(message.payload); break;
   26                 case 'SCORE_UPDATE': updateGameState(message.payload); break; // Main game state updates
   27                 case 'GAME_OVER': gameOver(message.payload); break;
   28                 // ... (other message types) ...
   29             }
   30         }
   31
   32         function fetchLeaderboard() {
   33             // Make an HTTP GET request to the REST API for leaderboard data
   34             fetch('/api/leaderboard')
   35                 .then(response => response.json())
   36                 .then(data => { /* ... update UI ... */ });
   37         }
       * Your explanation point: "On the frontend, in game.js, I wrote the JavaScript code to establish and manage the WebSocket connection. This includes using SockJS and
         Stomp.js libraries to connect to the server and subscribe to game updates (/topic/game). When I press a key to move or shoot, the sendAction() function sends an
         appropriate message to the server (/app/action). I also implemented fetchLeaderboard() to make a regular web request to our REST API endpoint to get and display the
         high scores."

   5. `MessageType.java`, `GameMessage.java`, `PlayerAction.java` (Messaging Structure)
       * Purpose: These Java classes define the structure of the messages exchanged over WebSockets.
       * `MessageType.java`: An enum (a fixed list of choices) defining all the possible types of messages (e.g., GAME_START, SCORE_UPDATE, SHOOT).
       * `GameMessage.java`: A generic wrapper object that contains a MessageType and a payload (the actual data, like the full GameState).
       * `PlayerAction.java`: A simple object representing a player's input, containing the player name and the action (e.g., "UP", "SHOOT").
       * Your explanation point: "I helped design the message structure for our WebSocket communication. MessageType.java lists all the different types of messages (like
         GAME_START or SCORE_UPDATE), GameMessage.java is a standard 'envelope' for sending these messages with their data, and PlayerAction.java defines how player inputs
         are sent to the server."

  ---

  This should give you a very detailed understanding of the networking aspect, connecting the backend and frontend code. Let me know when you're ready for the next section
  (Game Logic).Okay, let's break down Networking (WebSockets & REST APIs) for your presentation.

  Concept & Importance:
  WebSockets provide real-time, two-way communication crucial for dynamic game updates, while REST APIs handle less frequent, request-response data like leaderboard scores.
  This ensures fluid interaction and game state synchronization between the browser client and the Spring Boot server.

  Technologies Used:
   * WebSockets: Full-duplex communication for real-time updates.
   * STOMP: A messaging protocol layered over WebSockets for structured message exchange.
   * Spring Boot WebSocket (STOMP messaging): Spring's framework for building STOMP-over-WebSocket servers.
   * REST APIs: Request-response web services for less time-sensitive data.
   * `SockJS`: JavaScript library for WebSocket compatibility, providing fallbacks.
   * `Stomp.js`: JavaScript library for client-side STOMP messaging.

  Files/Classes & Your Contribution:

   1. `WebSocketConfig.java` (Server-Side WebSocket Setup):
       * Purpose: Configures the Spring Boot WebSocket server and its STOMP message broker.
       * Key Code: @EnableWebSocketMessageBroker enables WebSocket handling. configureMessageBroker routes /app messages from clients and broadcasts /topic messages to
         clients. registerStompEndpoints exposes /jet-game for client connections, with SockJS for compatibility.
       * Your explanation: "I configured the server-side WebSocket communication in WebSocketConfig.java. This sets up a message broker, routing client actions via /app and
         broadcasting game updates to clients via /topic, using SockJS for broad browser support."

   2. `GameController.java` (Handling Client Game Actions):
       * Purpose: Receives client game actions via WebSockets and dispatches them to GameService.
       * Key Code: @MessageMapping("/join") handles player joins, triggering game start logic. @MessageMapping("/action") handles player moves ("UP", "DOWN") and "SHOOT"
         actions, calling gameService.movePlayer and gameService.shoot respectively.
       * Your explanation: "In GameController.java, I implemented endpoints using @MessageMapping to process player actions sent over WebSockets. This lets the server know,
         in real-time, when players join, move, or shoot."

   3. `LeaderboardController.java` (REST API for Scoreboard):
       * Purpose: Exposes an HTTP endpoint for the frontend to retrieve leaderboard data.
       * Key Code: @RestController and @RequestMapping("/api/leaderboard") define the controller. @GetMapping on getLeaderboard() serves top 10 scores via
         leaderboardRepository.
       * Your explanation: "I created a REST API endpoint in LeaderboardController.java (/api/leaderboard) that the frontend uses to fetch and display the top 10 scores from
         the game's leaderboard."

   4. `game.js` (Client-Side WebSocket & REST Interaction):
       * Purpose: Manages the client-side WebSocket connection, sends player actions, processes server updates, and fetches leaderboard data.
       * Key Code: stompClient = Stomp.over(new SockJS('/jet-game')) establishes the connection. stompClient.subscribe('/topic/game', ...) receives updates.
         stompClient.send("/app/join", ...) and sendAction() send data to the server. fetch('/api/leaderboard') retrieves leaderboard data. handleGameMessage() processes
         various message types.
       * Your explanation: "In game.js, I wrote the JavaScript to connect to the WebSocket server using SockJS and Stomp.js, subscribe to real-time game updates
         (/topic/game), and send player actions (/app/action). I also implemented the code to fetch and display the leaderboard data by calling the REST API."

   5. `MessageType.java`, `GameMessage.java`, `PlayerAction.java` (Messaging Structure):
       * Purpose: Define the structure of messages sent over WebSockets.
       * Key Code: MessageType.java is an enum listing message types (GAME_START, SCORE_UPDATE). GameMessage.java is a generic wrapper with a type and payload.
         PlayerAction.java encapsulates player inputs (player name, action).
       * Your explanation: "I contributed to designing the message structure used for communication. MessageType.java defines what kinds of messages can be sent,
         GameMessage.java is the standard format for sending any message, and PlayerAction.java specifically defines how player inputs are structured when sent to the
         server."

  This covers the networking in detail. Let me know when you're ready for the next section (Game Logic).
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ ✓  WriteTodos Set 4 todo(s)                                                                                                                                                │
│                                                                                                                                                                            │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
✦ Okay, I'll explain Game Logic (Core Gameplay, Movement, Collision) for our Java game, A-Z.
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ ✓  WriteTodos Set 4 todo(s)                                                                                                                                                │
│                                                                                                                                                                            │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
✦ 4. Game Logic (Core Gameplay, Movement, Collision, Power-Ups)

  Concept: How does the game actually "play"?
   * This is the heart of the game – all the rules, physics, and interactions that make it work. It defines how jets move, how bullets fly, how hitting an opponent affects
     the score, and how power-ups change the game.
   * The server (GameService.java) is the single source of truth for all game logic to ensure fair play and synchronization between players. The frontend simply displays what
     the server calculates.

  Why is it important for our game?
   * Fair Play: All players see the exact same game state and rules enforced by the server.
   * Gameplay Mechanics: Defines how players interact with the game world and each other.
   * Responsiveness: Ensures actions are processed and reflected accurately.

  Technologies Used (A-Z):

   * Java Primitive Types (`double`, `int`, `long`, `boolean`): Used for storing numerical values (coordinates, scores, durations) and flags.
   * Java Collections (`ArrayList`, `List`): Used to manage dynamic collections of game entities (players, bullets, power-ups).
   * `Math.max()`, `Math.min()`: Used for boundary checking (e.g., keeping players on screen).

  Files/Classes Involved & How Game Logic is Implemented:

   1. `GameState.java` (The Snapshot of the Game World)
       * Purpose: This class (com.example.jetgame.model.GameState) holds the complete current status of the game at any given moment. It's the "snapshot" the server sends to
         the clients.
       * Key Code & Why:

    1         package com.example.jetgame.model;
    2         import java.util.ArrayList;
    3         import java.util.List;
    4
    5         public class GameState {
    6             private List<Player> players = new ArrayList<>();   // List of all active Player objects
    7             private List<Bullet> bullets = new ArrayList<>();   // List of all active Bullet objects
    8             private List<PowerUp> powerUps = new ArrayList<>(); // List of all active PowerUp objects
    9
   10             // ... (constructor, getters, setters) ...
   11         }
       * Your explanation point: "I helped define the GameState class, which is a critical part of the game logic. It acts as a single, comprehensive snapshot of everything
         happening in the game – where all players are, where all bullets are, and what power-ups are active. The server constantly updates this GameState and sends it to
         everyone to keep the game synchronized."

   2. `Player.java` (The Player's State)
       * Purpose: This class (com.example.jetgame.model.Player) defines everything unique about a player's jet within the game.
       * Key Code & Why:

    1         package com.example.jetgame.model;
    2         import java.util.HashMap;
    3         import java.util.Map;
    4
    5         public class Player {
    6             private String name;    // Player's identifier
    7             private double x, y;    // Current position on the game map
    8             private int width, height; // Size of the player's jet
    9             private int score;      // Player's current score
   10             // Map to track active power-ups and their expiration times
   11             private Map<PowerUp.PowerUpType, Long> activePowerUps = new HashMap<>();
   12
   13             // ... (constructor, getters, setters) ...
   14
   15             public void applyPowerUp(PowerUp powerUp) {
   16                 // Stores the power-up type and when it should expire
   17                 activePowerUps.put(powerUp.getType(), System.currentTimeMillis() + powerUp.getDuration());
   18             }
   19
   20             public boolean hasPowerUp(PowerUp.PowerUpType type) {
   21                 // Checks if a power-up is active AND not yet expired
   22                 return activePowerUps.containsKey(type) && activePowerUps.get(type) > System.currentTimeMillis();
   23             }
   24         }
       * Your explanation point: "I defined the Player class, which keeps track of each player's individual information, like their position on the screen, their current
         score, and importantly, which power-ups they currently have active. The applyPowerUp() and hasPowerUp() methods manage how power-ups are activated and checked to see
         if they're still in effect."

   3. `Bullet.java` (The Bullet's State)
       * Purpose: This class (com.example.jetgame.model.Bullet) defines a single bullet in the game.
       * Key Code & Why:

   1         package com.example.jetgame.model;
   2         public class Bullet {
   3             private double x, y; // Current position
   4             private double speed; // How fast and in which direction it moves
   5             private double width, height; // Size of the bullet
   6             private String shooterName; // Crucial for knowing who fired it (so it doesn't hit them!)
   7
   8             // ... (constructor, getters, setters) ...
   9         }
       * Your explanation point: "I created the Bullet class to represent each projectile fired in the game. It stores the bullet's position, size, speed, and shooterName.
         This shooterName is very important for game logic so that a bullet doesn't accidentally hit the player who fired it, and so the correct player gets points when an
         opponent is hit."

   4. `PowerUp.java` (The Power-Up's State)
       * Purpose: This class (com.example.jetgame.model.PowerUp) defines a power-up object in the game world.
       * Key Code & Why:

   1         package com.example.jetgame.model;
   2         public class PowerUp {
   3             public enum PowerUpType { BIG_BULLET, FAST_MOVEMENT, DOUBLE_SCORE }
   4             private PowerUpType type; // What kind of power-up it is
   5             private double x, y;      // Position on the game map
   6             private long duration;    // How long its effect lasts
   7
   8             // ... (constructor, getters, setters) ...
   9         }
       * Your explanation point: "I defined the PowerUp class and its different PowerUpTypes (like BIG_BULLET for bigger bullets, FAST_MOVEMENT for speed, and DOUBLE_SCORE
         for extra points). Each power-up knows its type, where it is on the map, and how long its effect should last."

   5. `GameService.java` (The Game Master!)
       * Purpose: This is the most critical component for game logic. It's the "brain" of the game, managing all state changes, player actions, updates, and collisions.
       * Key Code & Why:
           * `addPlayer(String playerName)`:

    1             public void addPlayer(String playerName) {
    2                 // ... (resetGame logic) ...
    3                 if (playerNames.size() == 2 && gameState.getPlayers().isEmpty()) {
    4                     // Create Player 1 (left side) and Player 2 (right side) at starting positions
    5                     Player player1 = new Player(playerNames.get(0), 50, GAME_HEIGHT / 2 - PLAYER_HEIGHT / 2);
    6                     Player player2 = new Player(playerNames.get(1), GAME_WIDTH - 50 - player1.getWidth(), GAME_HEIGHT / 2 - PLAYER_HEIGHT / 2);
    7                     gameState.getPlayers().add(player1);
    8                     gameState.getPlayers().add(player2);
    9                     gameStartTime = System.currentTimeMillis();
   10                     gameOver = false;
   11                     startPowerUpSpawner(); // Start generating power-ups
   12                 }
   13             }
           * `resetGame()`:

   1             public void resetGame() {
   2                 stopPowerUpSpawner(); // Stop old power-ups from spawning
   3                 gameState = new GameState(); // Create a completely new, fresh game state
   4                 playerNames.clear(); // Clear registered player names
   5                 gameOver = false;
   6                 gameStartTime = 0;
   7             }
              Your explanation point for `addPlayer` and `resetGame`: "I designed the addPlayer method to handle players joining and making sure the game starts cleanly. When
  the first player joins, or if a previous game ended, resetGame() is called to completely wipe the game state and prepare for a fresh match. Then, when two players are
  ready, their Player objects are created and positioned correctly on the screen, and the power-up system is started."

           * `movePlayer(String playerName, String direction)`:

    1             public void movePlayer(String playerName, String direction) {
    2                 Player player = getPlayer(playerName); // Find the correct player object
    3                 if (player != null) {
    4                     double movementSpeed = 10;
    5                     if (player.hasPowerUp(PowerUp.PowerUpType.FAST_MOVEMENT)) { // Check for speed power-up
    6                         movementSpeed = 20;
    7                     }
    8                     if ("UP".equals(direction)) {
    9                         player.setY(Math.max(0, player.getY() - movementSpeed)); // Move up, keep on screen
   10                     } else if ("DOWN".equals(direction)) {
   11                         player.setY(Math.min(GAME_HEIGHT - PLAYER_HEIGHT, player.getY() + movementSpeed)); // Move down, keep on screen
   12                     }
   13                 }
   14             }
              Your explanation point for `movePlayer`: "I implemented the movePlayer method, which takes player input (like 'UP' or 'DOWN') and updates their jet's vertical
  position. It also checks if the player has the FAST_MOVEMENT power-up and adjusts their speed accordingly, making sure they stay within the screen boundaries."

           * `shoot(String playerName)`:

    1             public void shoot(String playerName) {
    2                 Player player = getPlayer(playerName);
    3                 if (player != null) {
    4                     double bulletSpeed = 10;
    5                     double bulletWidth = 10;
    6                     if (player.hasPowerUp(PowerUp.PowerUpType.BIG_BULLET)) { // Check for big bullet power-up
    7                         bulletWidth = 20;
    8                     }
    9                     // Create a new Bullet object, setting its initial position, speed, and who shot it.
   10                     // Player 1 shoots right, Player 2 shoots left.
   11                     if (player.getName().equals(playerNames.get(0))) { // Player 1
   12                         gameState.getBullets().add(new Bullet(player.getX() + player.getWidth(), player.getY() + player.getHeight() / 2 - BULLET_HEIGHT / 2, bulletSpeed
      bulletWidth, playerName));
   13                     } else { // Player 2
   14                         gameState.getBullets().add(new Bullet(player.getX() - bulletWidth, player.getY() + player.getHeight() / 2 - BULLET_HEIGHT / 2, -bulletSpeed,
      bulletWidth, playerName));
   15                     }
   16                 }
   17             }
              Your explanation point for `shoot`: "I implemented the shoot method, which is called when a player fires. This method creates a new Bullet object, positions it
  correctly coming from the player's jet, sets its speed (left or right), and records who fired it. It also checks for the BIG_BULLET power-up to make the bullet larger if
  active."

           * `update()` (The Game Loop Step):

    1             public void update() {
    2                 // Game over timer check
    3                 if (System.currentTimeMillis() - gameStartTime > 30000) {
    4                     gameOver = true;
    5                     stopPowerUpSpawner();
    6                     saveGameResults(); // Save scores when game ends
    7                     return;
    8                 }
    9
   10                 List<Bullet> bullets = gameState.getBullets();
   11                 List<Player> players = gameState.getPlayers();
   12                 List<Bullet> bulletsToRemove = new ArrayList<>();
   13
   14                 // --- Bullet Movement and Player Collision ---
   15                 for (Bullet bullet : bullets) {
   16                     bullet.setX(bullet.getX() + bullet.getSpeed()); // Move bullet
   17                     if (bullet.getX() < 0 || bullet.getX() > GAME_WIDTH) { // Remove if out of bounds
   18                         bulletsToRemove.add(bullet);
   19                         continue;
   20                     }
   21                     for (Player player : players) {
   22                         if (bullet.getShooterName().equals(player.getName())) continue; // Don't hit self!
   23                         // AABB Collision Detection (bullet vs player)
   24                         if (bullet.getX() < player.getX() + player.getWidth() && /* ... other collision checks ... */) {
   25                             Player shooter = getPlayer(bullet.getShooterName());
   26                             if (shooter != null) {
   27                                 int scoreToAdd = 1;
   28                                 if (shooter.hasPowerUp(PowerUp.PowerUpType.DOUBLE_SCORE)) { // Double score power-up
   29                                     scoreToAdd = 2;
   30                                 }
   31                                 shooter.setScore(shooter.getScore() + scoreToAdd); // Add score to shooter
   32                             }
   33                             bulletsToRemove.add(bullet);
   34                             break; // Bullet hit, remove it
   35                         }
   36                     }
   37                 }
   38                 bullets.removeAll(bulletsToRemove);
   39
   40                 // --- Bullet-PowerUp Collection ---
   41                 List<PowerUp> powerUpsToRemove = new ArrayList<>();
   42                 List<Bullet> bulletsThatHitPowerUp = new ArrayList<>();
   43                 for (PowerUp powerUp : gameState.getPowerUps()) {
   44                     for (Bullet bullet : bullets) {
   45                         // AABB Collision Detection (bullet vs power-up)
   46                         if (bullet.getX() < powerUp.getX() + POWERUP_SIZE && /* ... other collision checks ... */) {
   47                             Player collectingPlayer = getPlayer(bullet.getShooterName());
   48                             if (collectingPlayer != null) {
   49                                 collectingPlayer.applyPowerUp(powerUp); // Apply power-up to shooter
   50                                 System.out.println(collectingPlayer.getName() + " collected power-up: " + powerUp.getType() + " with bullet.");
   51                                 powerUpsToRemove.add(powerUp);
   52                                 bulletsThatHitPowerUp.add(bullet);
   53                                 break;
   54                             }
   55                         }
   56                     }
   57                 }
   58                 gameState.getPowerUps().removeAll(powerUpsToRemove);
   59                 bullets.removeAll(bulletsThatHitPowerUp);
   60
   61                 // --- Expired Power-Up Cleanup ---
   62                 long currentTime = System.currentTimeMillis();
   63                 for (Player player : players) {
   64                     player.getActivePowerUps().entrySet().removeIf(entry -> entry.getValue() <= currentTime);
   65                 }
   66             }
              Your explanation point for `update`: "The update() method is the core game logic function that runs constantly. I implemented its various sections: it moves all
  bullets, checks if bullets hit players (and gives points to the shooter, doubling them if they have a DOUBLE_SCORE power-up), and also detects if bullets hit power-ups
  (assigning the power-up to the player who fired the bullet). It also cleans up expired power-ups and checks if the game timer has run out, triggering the end of the match
  and saving scores."

  ---

  This covers the game logic in detail. You now have a comprehensive breakdown of all major components with their "A-Z" details and explanations.

  Remember to tailor these explanations to your specific contribution areas for your presentation. Good luck!I'll provide an in-depth explanation of Game Logic, the "brain"
  of our game. This covers rules, physics, and interactions, all managed authoritatively by GameService.java to ensure synchronized, fair play. I'll explain its importance
  for consistent gameplay and responsiveness.

  Technologies Used: Java Primitive Types, Java Collections (ArrayList, List), Math.max(), Math.min().

  Files/Classes and Game Logic Implementation:

   1. `GameState.java` (The Snapshot of the Game World): This class (com.example.jetgame.model.GameState) holds the complete current status of the game (players, bullets,
      power-ups) and is sent to clients for synchronization.
       * Your explanation: "I defined the GameState class as the central snapshot of the game, tracking all players, bullets, and active power-ups, ensuring synchronization
         across all clients."

   2. `Player.java` (The Player's State): This class (com.example.jetgame.model.Player) defines player attributes, including position, score, and active power-ups, with
      methods to applyPowerUp() and hasPowerUp() for managing power-up effects.
       * Your explanation: "I defined the Player class to store individual player data like position and score, and implemented how power-ups are managed, including their
         activation and duration."

   3. `Bullet.java` (The Bullet's State): This class (com.example.jetgame.model.Bullet) defines bullet properties like position, speed, size, and crucially, shooterName to
      prevent self-hits and assign points correctly.
       * Your explanation: "I created the Bullet class, storing its position, speed, size, and shooterName which is vital for collision detection and score attribution."

   4. `PowerUp.java` (The Power-Up's State): This class (com.example.jetgame.model.PowerUp) defines power-up types (e.g., BIG_BULLET), positions, and durations.
       * Your explanation: "I defined the PowerUp class and its types, setting its position and duration to enhance gameplay."

   5. `GameService.java` (The Game Master!): The "brain" of the game, managing all state changes, actions, updates, and collisions.
       * `addPlayer(String playerName)` & `resetGame()`: Handles player joining, game reset, and initial player setup.
           * Your explanation: "I designed addPlayer to manage player entry, using resetGame() for clean starts. When players join, I ensure their Player objects are
             correctly initialized and positioned, and power-up spawning begins."
       * `movePlayer(String playerName, String direction)`: Updates player vertical position based on input, applying power-up speed bonuses and boundary checks.
           * Your explanation: "I implemented movePlayer to update jet positions based on input, applying speed power-ups and respecting screen boundaries."
       * `shoot(String playerName)`: Creates bullets with correct properties, including speed and shooterName, applying BIG_BULLET power-ups.
           * Your explanation: "I implemented shoot to create Bullet objects, setting their properties like shooterName and speed, and applying BIG_BULLET effects."
       * `update()` (The Game Loop Step): The core game logic function that runs constantly, handling bullet movement, player/power-up collision detection, score updates, and
         power-up expiration.
           * Your explanation: "The update() method is the game's core. I implemented its logic for moving bullets, detecting collisions with players (scoring for the
             shooter, with DOUBLE_SCORE power-up application), handling bullet-power-up collection (assigning to the shooter), cleaning up expired power-ups, and managing the
             game timer to trigger game over."

  This detailed breakdown connects "why" to "what" in your code. Good luck with your presentation!